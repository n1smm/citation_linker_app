"""
Bridge between Qt GUI and citation linker CLI tools.
Manages subprocess execution and path configuration.
"""
import  re
import  os
import  sys
import  subprocess
import  pymupdf
import  shutil
from    pathlib                         import  Path
from    PySide6.QtCore                  import  QObject, Signal, Slot
# from    citation_linker.configPaths     import  ensure_defaults

class Bridge(QObject):
    """
    Interface between Qt UI and citation-linker CLI.
    
    Parent: QObject
    Children: None
    
    Handles:
    - Configuration path management via citation-config
    - Subprocess execution of citation linking tools
    - Input/output directory management
    - Document saving and file operations
    """
    config_path_changed = Signal(str)
    linking_finished = Signal(bool, str)

    def __init__(self, parent=None):
        """Initialize bridge with parent app reference."""
        super().__init__(parent)
        
        # Ensure config directories and default files exist on first startup
        # ensure_defaults()

        self.parent = parent
        self.input_location = ""
        self.input_dir = ""
        self.output_location = ""
        self.output_dir= ""
        self.input_file_path = ""
        self.output_file_path = ""
        self.user_shell = self.get_user_shell()
        self.config_path = self.get_config_path()


    def get_user_shell(self):
        """Detect and return user's shell."""
        user_shell = os.environ.get("SHELL")
        if not user_shell and sys.platform == "win32":
            user_shell = os.environ.get("COMSPEC", "cmd.exe")
        self.user_shell = user_shell
        return user_shell

    def get_config_path(self):
        """
        Retrieve configuration paths from citation-config CLI tool.
        
        Executes 'citation-config --list' and parses the output to extract:
        - Config file location
        - Input directory
        - Output directory
        - Input/output location files
        
        Returns:
            str: Path to the configuration file
        """
        self.get_input_file_path()
        user_shell = self.get_user_shell()
        cmd  = "citation-config --list"
        kwargs = self.set_kwargs()

        try:
            result = subprocess.run(cmd, **kwargs)
            output = result.stdout
            print("*** config process output:", output)
            tokens = re.split(r":|\n", output)
            for idx, t in enumerate(tokens):
                if "config location" in t and tokens[idx+1]:
                    self.config_path = tokens[idx+1].strip()
                    print(f"Config path: {self.config_path}")
                elif "config path location file" in t and tokens[idx+1]:
                    self.config_location = tokens[idx+1].strip()
                    print(f"Config location: {self.config_location}")
                elif "input dir" in t and tokens[idx +1]:
                    self.input_dir = tokens[idx+1].strip()
                    print(f"input dir: {self.input_dir}")
                elif "output dir" in t and tokens[idx+1]:
                    self.output_dir = tokens[idx+1].strip()
                    print(f"output dir: {self.output_dir}")
                elif "output location" in t and tokens[idx+1]:
                    self.output_location = tokens[idx+1].strip()
                    print(f"output location: {self.output_location}")
                elif "input location" in t and tokens[idx+1]:
                    self.input_location = tokens[idx+1].strip()
                    print(f"input location: {self.input_location}")
            return self.config_path
        except Exception as e:
            print(f"Error getting config path: {e}")

    def get_input_file_path(self):
        """Get the current input file path from parent application."""
        self.input_file_path = self.parent.upload_path
        print("input file bridge component: ", self.input_file_path)

    def set_kwargs(self, shell=True):
        """
        Configure subprocess keyword arguments for shell command execution.
        
        Args:
            shell: Whether to use shell execution (default: True)
            
        Returns:
            dict: Keyword arguments for subprocess.run()
        """
        kwargs = {
                "shell": shell,
                "capture_output": True,
                "text": True
                }
        if self.user_shell and sys.platform != "win32":
            kwargs["executable"] = self.user_shell
        return kwargs

    def run_process(self, cmd, kwargs):
        """
        Execute a shell command and return its exit code.
        
        Args:
            cmd: Command string to execute
            kwargs: Keyword arguments for subprocess.run()
            
        Returns:
            int: Exit code (0 for success, non-zero for failure)
        """
        try:
            print("cmd:", cmd)
            result = subprocess.run(cmd, **kwargs)
            output = result.stdout
            print ("output: ", output)
            print("stderr:", result.stderr)
            return result.returncode
        except Exception as e:
            print(f"Error running process: {e}")
            return 1


    def set_paths(self, input_dir=None, output_dir=None, config_path=None):
        """
        Update input/output/config paths via citation-config CLI tool.
        
        Executes citation-config with --input, --output, and/or --config flags
        to persist path changes. Emits config_path_changed signal if config path is set.
        
        Args:
            input_dir: Path to input directory (optional)
            output_dir: Path to output directory (optional)
            config_path: Path to configuration file (optional)
        """
        cmd = "citation-config"
        if input_dir:
           cmd += f" --input {input_dir}"
        if output_dir:
            cmd += f" --output {output_dir}"
        if config_path:
            self.config_path_changed.emit(config_path)
            cmd += f" --config {config_path}"

        kwargs = self.set_kwargs(shell=True)
        self.run_process(cmd, kwargs)

    def start_linking_process(self, cmd_in=None):
        """
        Execute the citation linking process via CLI tool.
        
        Workflow:
        1. Save current configuration
        2. Copy input PDF to input directory
        3. Execute citation linking CLI (citation-multi-article by default)
        4. Verify output file was created
        5. Emit linking_finished signal with success status
        
        Args:
            cmd_in: CLI command to use (citation-linker, citation-multi-file, 
                   or citation-multi-article). Defaults to citation-multi-article.
                   
        Returns:
            tuple: (success: bool, output_file_path: str)
        """
        self.parent.document_config.save_config()
        self.get_input_file_path()
        base, ext = os.path.splitext(os.path.basename(self.input_file_path))
        self.delete_files_in_dir(self.input_dir)
        shutil.copy(self.input_file_path, os.path.join(self.input_dir, base+ext))
        output_file_base = base + "_linked" + ext
        output_file_path = os.path.join(self.output_dir, output_file_base)

        if cmd_in == "citation-linker" or cmd_in == "citation-multi-file":
            cmd = cmd_in
        else:
            cmd = "citation-multi-article"

        kwargs = self.set_kwargs(shell=True)
        return_code = self.run_process(cmd, kwargs)
        self.output_file_path = output_file_path
        print("output file path: ", output_file_path)
        
        success = return_code == 0 and os.path.exists(output_file_path)
        self.linking_finished.emit(success, output_file_path)
        return (success, output_file_path)


    def delete_files_in_dir(self, dir):
        """
        Delete all files in the specified directory.
        
        Used to clean the input directory before copying new PDF.
        Subdirectories are not removed.
        
        Args:
            dir: Directory path (currently unused, uses self.input_dir)
        """
        for filename in os.listdir(self.input_dir):
            file_path = os.path.join(self.input_dir, filename)
            if os.path.isfile(file_path):
                os.remove(file_path)

    def save_final_doc(self, pymu_doc):
        """
        Save the final processed document to output location.
        
        Uses atomic write (save to .tmp then replace) to avoid corruption
        if save fails partway through.
        
        Args:
            pymu_doc: PyMuPDF document object to save
        """
        if pymu_doc:
            temp_path = self.output_file_path + ".tmp"
            pymu_doc.save(temp_path)
            os.replace(temp_path, self.output_file_path)
            print("file saved")



if __name__ == "__main__":
    bridge = Bridge()
    config_path = bridge.get_config_path()
    bridge.set_paths(input_dir="/home/thiew/code_tuts_other/citation_linker_app/QtApp/input",
                     output_dir="/home/thiew/code_tuts_other/citation_linker_app/QtApp/output")
    print(bridge.input_dir)
    print(bridge.output_dir)
